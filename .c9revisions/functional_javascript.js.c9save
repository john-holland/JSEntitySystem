{"ts":1344349992583,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"Array.prototype.Map = function(func) {\r\n    var mappedArray = new Array(this.length);\r\n\tvar i;\r\n\t\r\n\tfor (i = 0; i < this.length; i++) {\r\n\t\tmappedArray[i] = func(this[i]);\r\n\t}\r\n\t\r\n\treturn mappedArray;\r\n}\r\n\r\nArray.prototype.Select = Array.prototype.Map;\r\n\r\n//takes a function that takes: (accumulated, currentElement)\r\nArray.prototype.Fold = function(initialVal, func) {\r\n\tvar ret = initialVal;\r\n    var i;\r\n\tfor (i = 0; i < this.length; i++) {\r\n\t\tret = func(ret, this[i]);\r\n\t}\r\n\t\r\n\treturn ret;\r\n}\r\n\r\nArray.prototype.Aggregate = Array.Fold;\r\n\r\nArray.prototype.Find = function(predicate) {\r\n\tvar matches = [];\r\n\t\r\n\tvar i;\r\n\tfor (i = 0; i < this.length; i++) {\r\n\t\tif (predicate(this[i]))\r\n\t\t{\r\n\t\t\tmatches.push(this[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn matches;\r\n}\r\n\r\nArray.prototype.Where = Array.prototype.Find;\r\nArray.prototype.Filter = Array.prototype.Find;\r\n\r\nArray.prototype.First = function() {\r\n\treturn this[0];\r\n}\r\n\r\nArray.prototype.Last = function() {\r\n\treturn this[(this.length - 1)];\r\n}\r\n\r\nArray.prototype.Skip = function(amount) {\r\n\tvar remaining = this.length - amount;\r\n\t\r\n\t//can't skip more than exist!\r\n\tif (remaining > 0) {\r\n\t\tvar skipped = new Array(remaining);\r\n\t\r\n\t\tvar i;\r\n\t\tfor (i = amount; i < this.length; i++) {\r\n\t\t\tskipped[i];\r\n\t\t}\r\n\t\t\r\n\t\treturn skipped;\r\n\t}\r\n\t\r\n\treturn null;\r\n}\r\n\r\nArray.prototype.Take = function(amount) {\r\n\tif (this.length > amount) {\r\n\t\tamount = this.length;\r\n\t}\r\n\t\r\n\tvar takenElements = new Array(amount);\r\n\t\r\n\tvar i;\r\n\tfor (i = 0; i < amount; i++) {\r\n\t\ttakenElements[i] = this[i];\r\n\t}\r\n\t\r\n\treturn takenElements;\r\n}\r\n\r\n/*\r\n  The Any function accepts either a predicate function, a predicate object or\r\n  no parameter (in which case it simply checks to see if the Array has anything at all).\r\n  \r\n  Usage:\r\n  var collection = new Array(1, 2, 3);\r\n  \r\n  if (collection.Any(function(x) { return x == 3 })) {\r\n    //Yes it does have 3!\r\n  }\r\n  \r\n  if (collection.Any(2)) {\r\n    //yup it has 2!\r\n  }\r\n  \r\n  if (collection.Any()) {\r\n    //yup it has stuff.\r\n  }\r\n*/\r\nArray.prototype.Any = function(predicate) {\r\n    if (typeof predicate == 'undefined') {\r\n        return (this.length > 0);\r\n    }\r\n    \r\n    var i;\r\n    \r\n    if (typeof predicate == 'Function') {\r\n        for (i = 0; i < this.length; i++) {\r\n            if (predicate(this[i])) {\r\n                return true;\r\n            }\r\n        }\r\n    } else {        \r\n        for (i = 0; i < this.length; i++) {\r\n            if (this[i] === predicate) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n\r\n\r\n/* TODO FixME!?\r\n//Takes a function, then some arguments and stores them so that you can later\r\n//Call that function and it will remember its args.\r\n\r\n\tFor example,\r\n\t\r\n\tfunction plus(x, y)\r\n\t{\r\n\t\treturn x + y;\r\n\t}\r\n\t\r\n\tvar fivePlus(5).Curry();\r\n*/\r\nFunction.prototype.Curry = function() {\r\n    var args = new Array(arguments.length);\r\n    \t\r\n    var i;\r\n    for (i = 0; i < arguments.length; i++) {\r\n        args[i] = arguments[i];\r\n    }\r\n    \r\n    return function() {\r\n        return this.apply(this, args.concat(arguments));\r\n    };\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":3077}]],"length":3077}
